++++++++++++++++++++++++++++++++++++++++ Section 1 - Introduction ++++++++++++++++++++++++++++++++++++++++

Why Multithreading?

    1. Take full advantage of modern hardware.
    2. Make programs more responsive.
    3. Everything is becoming threaded.
    4. Valuable skill in today's world.

++++++++++++++++++++++++++++++++++++++++ Section 2 - Review of Modern C++ Features ++++++++++++++++++++++++++++++++++++++++

Modern C++ Overview Part One -

    1. universal initialization
        1. Initializer(s) within a pair of braces.
        2. Can be used with any type.
            int x{7};                           // Equivalent to int x = 7;
            std::string str{"Let us begin"};    // Equivalent to string str("Let us begin");
        3. Narrowing conversions are not allowed.
            int x = 7.7;   // Legal, although compilers may warn
            int x{7.7};    // Illegal
        4. It can be used with compound types.
            std::vector<int>vec{4,2,3,5,1};

    2. null (C++98)
        1. Has the value 0.
        2. Its type is implementation defined.
            // Two functions which are overloaded
            void func(int);
            void func(int*);

            func(NULL); 
                // Calls func(int*) with clang
                // Calls func(int) with VC++
                // Does not compile with gcc

    3. nullptr (C++11 and above)
        1. A literal which represents a null pointer.
        2. It has a special type.
            1. Compatible with any pointer type.
            2. Cannot be converted to an integer.
            // Two functions which are overloaded
            void func(int);
            void func(int*);

            func(nullptr);    // Calls func(int*) as expected
    
    4. std::chrono durations
        1. Types which represent time intervals.
            1. Defined in <chrono>
            2. In the std::chrono namespace
            // Namespace alias to simplify the code
            namespace sc = std::chrono;
            sc::seconds(2);          // 2 second interval
            sc::milliseconds(20);    // 20 millisecond interval
            sc::microseconds(50);    // 50 microsecond interval

    5. std::chrono literals
        1. C++14 provides literals for these time intervals in the std::chrono::literals namespace.
        2. This is an inline namespace.
            using namespace std::literals;
            2s      // 2 second interval
            20ms    // 20 millisecond interval
            50us    // 50 microsecond interval
    
    6. auto type specifier, qualifier, and for-loop
        1. The compiler deduces the type from the initializer.
            auto x = 6;   // Equivalent to int x = 6;
            auto x{6};    // Equivalent to int x{6};    
        2. This is very useful with complicated types.
            std::vector<std::string>vec;
            auto it = vec.begin();    // Equivalent to std::vector<std::string>::iterator it = vec.begin();
        3. In modern C++, there are some cases where the type cannot be known by the programmer.
        4. auto will only give the underlying type.
            auto x = 6;    // x deduced as non-const
        5. const, reference, etc are ignored.
            const std::string& str = "Hello";    // Reference to a const string
            auto s = str;
                // s has type std::string
                // It is a mutable copy of str
        6. If we need them, we must add them ourselves
            const std::string& str = "Hello";
            const auto& s = str; 
                // s is a const reference to std::string
        7. We can use auto to simplify for-loop.
            std::vector<int>vec{4,3,1,2,5};
            for(auto it=vec.begin(); it!=vec.end(); ++it)
                std::cout<<*it<<" ";    // Prints out each element of vec
            for(auto it=vec.begin(); it!=vec.end(); ++it)
                *it+=2;    // Adds 2 to each element of vec 
        8. Special syntax for iterating over containers. To visit each element once, in order, without adding or removing elements. Otherwise, use a traditional loop.    
            std::vector<int>vec{4,3,1,2,5};
            for(auto i: vec)
                std::cout<<i<<" ";    // Prints out each element of vec
            // We need to use a reference to modify the elements
            for(auto& i: vec) 
                i+=2;


Modern C++ Overview Part Two - 

    1. lambda expression
        1. Similar to "closures" in other languages.
        2. Can be thought of as "local functions".
            1. Anonymous functions
            2. Defined inline in a single statement
        3. Ideal for short, simple helper functions which are only used once.
        4. Useful for passing as function arguments.
            1. More convenient than functors or function pointers.
        5. Can also be returned by functions.
        6. Very useful as predicates for algorithm calls.

    2. lambda expression syntax
        1. Similar to functions.
        2. Put [] instead of the function name.
        3. Write the arguments in the usual way.
        4. Write its body inline.
            [] (int arg) { return (2 * arg); };

    3. return type
        1. Deduced by the compiler in C++14.
            1. The return type must be the same in all paths.
            2. In C++17, can differ.
        2. In C++11, deduced for a single statement which returns a value.
            [] (int arg) { return (2 * arg); };
        3. Otherwise, must be specified with a trailing return type.
            [] (int arg) -> int { arg = (2 * arg); return arg; };

    4. callable object
        1. A lambda expression is a callable object.
        2. To invoke it, put a () after the body, with any arguments.
            [] (int arg) { return (2 * arg); }(3);    // Invoke the lambda with argument 3
        3. It can be stored in a variable of type auto.
            auto lam = [] (int arg) { return (2 * arg); };
                // Store the lambda in a variable
                // The compiler will provide the type (not known to us)
    
    5. capture
        1. capture by value
            1. A lambda expression can capture a local variable.
                1. Makes it available in the lambda's body.
                2. Put the name of the variable(s) inside the [].
                3. The lambda body contains an immutable copy of the local variable.
                    int n = 2;
                    [n] (int arg) { return (n * arg); };    // Captures the local variable n (immutable copy)
        2. capture by reference
            1. The lambda can change a captured variable.
            2. Put a & before the variable's name.
                int n = 2;
                [&n] (int arg) { return (++n * arg); };    // Captures the local variable n by reference

    6. implicit capture
        1. Captures all variables in scope.
            1. [=] captures all variables by value.
            2. [&] captures all variables by reference.
        2. We can be more selective.
            1. [=, &x] captures x by reference, all others by value.
            2. [&, =a, =b] captures a and b by value, all others by reference.

    7. lambda expressions in member functions
        1. To access the data members, capture "this".
            1. [this] () { return m_data % 2; };    // Captures all data members by reference
        2. The object is captured as a reference to *this.
        3. The lambda expression is able to modify data members.
            [this] (int arg) { return ++m_data * arg; };
    
    8. lambda expression example
        // Call std::count_if() algorithm using a lambda expression as predicate
        auto n_even = count_if(vec.begin(), vec.end(), 
            // The lambda definition goes inside the call
            [] (int n) { 
                return (n % 2 == 0); 
            }
        );

Keep Coding!!!