++++++++++++++++++++++++++++++++++++++++ Section 2 - Review of Modern C++ Features ++++++++++++++++++++++++++++++++++++++++

Modern C++ Overview Part One -

    1. universal initialization
        1. Initializer(s) within a pair of braces.
        2. Can be used with any type.
            int x{7};                           // Equivalent to int x = 7;
            std::string str{"Let us begin"};    // Equivalent to string str("Let us begin");
        3. Narrowing conversions are not allowed.
            int x = 7.7;   // Legal, although compilers may warn
            int x{7.7};    // Illegal
        4. It can be used with compound types.
            std::vector<int>vec{4,2,3,5,1};

    2. null (C++98)
        1. Has the value 0.
        2. Its type is implementation defined.
            // Two functions which are overloaded
            void func(int);
            void func(int*);

            func(NULL); 
                // Calls func(int*) with clang
                // Calls func(int) with VC++
                // Does not compile with gcc

    3. nullptr (C++11 and above)
        1. A literal which represents a null pointer.
        2. It has a special type.
            1. Compatible with any pointer type.
            2. Cannot be converted to an integer.
            // Two functions which are overloaded
            void func(int);
            void func(int*);

            func(nullptr);    // Calls func(int*) as expected
    
    4. std::chrono durations
        1. Types which represent time intervals.
            1. Defined in <chrono>
            2. In the std::chrono namespace
            // Namespace alias to simplify the code
            namespace sc = std::chrono;
            sc::seconds(2);          // 2 second interval
            sc::milliseconds(20);    // 20 millisecond interval
            sc::microseconds(50);    // 50 microsecond interval

    5. std::chrono literals
        1. C++14 provides literals for these time intervals in the std::chrono::literals namespace.
        2. This is an inline namespace.
            using namespace std::literals;
            2s      // 2 second interval
            20ms    // 20 millisecond interval
            50us    // 50 microsecond interval
    
    6. auto type specifier, qualifier, and for-loop
        1. The compiler deduces the type from the initializer.
            auto x = 6;   // Equivalent to int x = 6;
            auto x{6};    // Equivalent to int x{6};    
        2. This is very useful with complicated types.
            std::vector<std::string>vec;
            auto it = vec.begin();    // Equivalent to std::vector<std::string>::iterator it = vec.begin();
        3. In modern C++, there are some cases where the type cannot be known by the programmer.
        4. auto will only give the underlying type.
            auto x = 6;    // x deduced as non-const
        5. const, reference, etc are ignored.
            const std::string& str = "Hello";    // Reference to a const string
            auto s = str;
                // s has type std::string
                // It is a mutable copy of str
        6. If we need them, we must add them ourselves
            const std::string& str = "Hello";
            const auto& s = str; 
                // s is a const reference to std::string
        7. We can use auto to simplify for-loop.
            std::vector<int>vec{4,3,1,2,5};
            for(auto it=vec.begin(); it!=vec.end(); ++it)
                std::cout<<*it<<" ";    // Prints out each element of vec
            for(auto it=vec.begin(); it!=vec.end(); ++it)
                *it+=2;    // Adds 2 to each element of vec 
        8. Special syntax for iterating over containers. To visit each element once, in order, without adding or removing elements. Otherwise, use a traditional loop.    
            std::vector<int>vec{4,3,1,2,5};
            for(auto i: vec)
                std::cout<<i<<" ";    // Prints out each element of vec
            // We need to use a reference to modify the elements
            for(auto& i: vec) 
                i+=2;


Modern C++ Overview Part Two - 

    1. lambda expression
        1. Similar to "closures" in other languages.
        2. Can be thought of as "local functions".
            1. Anonymous functions
            2. Defined inline in a single statement
        3. Ideal for short, simple helper functions which are only used once.
        4. Useful for passing as function arguments.
            1. More convenient than functors or function pointers.
        5. Can also be returned by functions.
        6. Very useful as predicates for algorithm calls.

    2. lambda expression syntax
        1. Similar to functions.
        2. Put [] instead of the function name.
        3. Write the arguments in the usual way.
        4. Write its body inline.
            [] (int arg) { return (2 * arg); };

    3. return type
        1. Deduced by the compiler in C++14.
            1. The return type must be the same in all paths.
            2. In C++17, can differ.
        2. In C++11, deduced for a single statement which returns a value.
            [] (int arg) { return (2 * arg); };
        3. Otherwise, must be specified with a trailing return type.
            [] (int arg) -> int { arg = (2 * arg); return arg; };

    4. callable object
        1. A lambda expression is a callable object.
        2. To invoke it, put a () after the body, with any arguments.
            [] (int arg) { return (2 * arg); }(3);    // Invoke the lambda with argument 3
        3. It can be stored in a variable of type auto.
            auto lam = [] (int arg) { return (2 * arg); };
                // Store the lambda in a variable
                // The compiler will provide the type (not known to us)
    
    5. capture
        1. capture by value
            1. A lambda expression can capture a local variable.
                1. Makes it available in the lambda's body.
                2. Put the name of the variable(s) inside the [].
                3. The lambda body contains an immutable copy of the local variable.
                    int n = 2;
                    [n] (int arg) { return (n * arg); };    // Captures the local variable n (immutable copy)
        2. capture by reference
            1. The lambda can change a captured variable.
            2. Put a & before the variable's name.
                int n = 2;
                [&n] (int arg) { return (++n * arg); };    // Captures the local variable n by reference

    6. implicit capture
        1. Captures all variables in scope.
            1. [=] captures all variables by value.
            2. [&] captures all variables by reference.
        2. We can be more selective.
            1. [=, &x] captures x by reference, all others by value.
            2. [&, =a, =b] captures a and b by value, all others by reference.

    7. lambda expressions in member functions
        1. To access the data members, capture "this".
            1. [this] () { return m_data % 2; };    // Captures all data members by reference
        2. The object is captured as a reference to *this.
        3. The lambda expression is able to modify data members.
            [this] (int arg) { return ++m_data * arg; };
    
    8. lambda expression example
        // Call std::count_if() algorithm using a lambda expression as predicate
        auto n_even = std::count_if(vec.begin(), vec.end(), 
            // The lambda definition goes inside the call
            [] (int n) { 
                return (n % 2 == 0); 
            }
        );


Modern C++ Overview Part Three - 

    1. move semantics
        1. C++11 optimization for copying objects.
            1. In some cases, the data can be moved into the target.
            2. Similar to moving files between folders.
        2. This is an important optimization, since C++ copies by default.
        3. Suppose, we have,
            1. Problem
                1. Consider how it could be executed more efficently.
                    std::vector<std::string>vec(1000000);    // A vector of 1 million strings
                    ....                                     // Polpulate vector
                    func(vec);                               // Move vec's data into the function argument
                    ....                                     // vec is not used again
                    ....
                2. When func() is called
                    1. No memory is allocated.
                    2. The elements are moved from vec into the function argument.
                    3. After the function call, vec is an empty vector.
            2. Solution
                1. Make func() argument an rvalue reference.
                    void func(std::vector<std::string>&& arg);
                    ....
                    std::vector<std::string> vec(1000000);    // A vector of 1 million strings
                    func(vec);                                // Doesn't compile
                2. An lvalue cannot be moved.

    2. lvalue and rvalue before C++ 
        1. A value can be either an lvalue or an rvalue.
        2. An lvalue may appear on the left of an assignment.
        3. An rvalue can only appear on the right.
            x = 2;    // x is an lvalue, 2 is an rvalue
            2 = x;    // Not legal C 

            x = func();    // x is an lvalue, func() is an rvalue
            func() = x;    // Not legal C, but can be legal in C++

    3. lvalue and rvalue in C++
        1. In C++, an lvalue represents a named memory location.
            1. It has a name.
            2. We can take its address using the & operator.
            3. x is an lvalue.    // name is x, &x is legal
        2. Anything else is an rvalue.
            1. 2 is an rvalue.         // 2 has no name, &2 is not legal
            2. func() is an rvalue.    // return value from function call has no name, &func() is not legal

    4. reference
        1. lvalue reference
            1. A reference is typically implemented as a pointer.
            2. The compiler adds code to dereference the pointer.
                int x;
                int& y = x;    // Equivalent to int *y = &x;
                y = 3;         // Equivalent to *y = 3;
            3. This requires that x has an address.
                1. x must be an lvalue.
            4. This is now known as an "lvalue reference".
        2. rvalue reference
            1. C++11 has the concept of an "rvalue reference".
            2. An rvalue reference has a && after the type.
                void func(int&& x);    // function argument is an rvalue reference 
                
                func(2);               // 2 is an rvalue, ok
                                       
                int y = 2;             
                func(y);               // y is an lvalue, not ok (error)
            3. This is a syntactic device.
                1. Indicates that a function argument must be a movable rvalue.
        3. moving into a function argument
            1. A function argument can be an "rvalue reference".
            2. The passed object will be moved into the argument, if
                1. The object is an rvalue.
                2. And, its type is moveable.
            3. Otherwise, the call doesn't compile.
    
    5. std::move()
        1. The std::move() will cast its argument to rvalue.
            // std::move() casts vec to an rvalue
            func(std::move(vec));
        2. This will move vec's data into the function argument.
        3. This should only be done if vec's data is expendable.
            1. After calling func(), vec's data may be empty or unusable.
            2. If we want to use vec again, we must re-assign its data.


Modern C++ Overview Part Four - 

    1. rvalue reference and overloading
        1. Functions can be overloaded on the value type.
            1. Different behavior for lvalues and rvalues.
                void func(const Test& test);    // Called when we pass an lvalue
                void func(Test&& test);         // Called when we pass an rvalue
        2. Usually, the lvalue version will be called.
            1. When we pass a variable.
        3. The rvalue overload will be called.
            1. If we pass a literal or a temporary object.
            2. If we use std::move() to cast a variable.
    
    2.  std::move() semantics and ownership
        1. Consider these overloads.
            void func(const Test& test);    // Called when we pass an lvalue
            void func(Test&& test);         // Called when we pass an rvalue
        2. lvalue argument
            1. Refers to an object outside func().
            2. The function can inspect this object.
            3. It can make its own copy of the object.
        3. rvalue argument
            1. Not owned by any variable.
            2. Or, the variable has lost ownership after a call to std::move().
            3. The "test" object becomes the owner.
    
    3. std::move operator
        1. C++11 has two new special member functions.
            1. The arguments are rvalue references.
        2. Overload of the copy constructor.
            // std::move constructor
            Test(Test&& other) noexcept;
        3. Overload of the assignment operator.
            // std::move assignment operator
            Test& operator = (Test&& other) noexcept;
        4. These operators are called during move operations.
            1. An object is only moveable if the class defines move operators.
    
    4. move-only types
        1. In C++11, some types can be moved, but not copied.
            1. std::fstream, std::iostream
            2. std::unique_ptr
            3. Classes used in multi-threading.
        2. These types follow the RAII (Resource Acquisition Is Initialization) idiom.
            1. Only one object can own a given resource instance at a time.
            2. The object acquires ownership in the constructor.
            3. The object releases ownership in the destructor.
            4. The resource instance can be moved from one object to another.
    
    5. std::fstream
        1. A std::fstream has a file handle as a data member.
            1. The constructor opens the file.
            2. The destructor closes the file.
        2. A std::fstream object cannot be copied, but it can be moved.
            1. The moved-from object no longer owns the file handle.
            2. The moved-to object becomes the owner of the file handle.
            3. The file will be closed when the moved-to object is destroyed.

    6. deleted and defaulted operators
        1. In C++11, special member functions can be deleted.
            Test(const Test& other) = delete;    // Deleted copy constructor
        2. This prevents an object from being copied.
            1. The function is defined, but cannot be called.
        3. Special member functions can also be defaulted.
            Test(const Test& other) = default;    // Defaulted copy constructor
        4. This causes the compiler to generate a default member function.
            1. The default copy constructor copies all the class members. 

    7. pass by value ..., or, pass by move
        1. In older C++, the argument is always copied by default.
            // This function makes its own copy of test
            void func(Test test);
        2. In C++11, the argument can be moved, if
            1. It is an rvalue.
            2. And, the type defines move operators.
        3. Otherwise, it will be copied.
            1. Provides compatibility with old code.
        4. All STL containers are moveable.
            1. And, almost all other C++ library types.
            2. All built-in types are regarded as moveable (but are always copied).


Keep Coding!!!