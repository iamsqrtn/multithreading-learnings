++++++++++++++++++++++++++++++++++++++++ Section 1 - Introduction ++++++++++++++++++++++++++++++++++++++++

Why Multithreading?

    1. Take full advantage of modern hardware.
    2. Make programs more responsive.
    3. Everything is becoming threaded.
    4. Valuable skill in today's world.

++++++++++++++++++++++++++++++++++++++++ Section 2 - Review of Modern C++ Features ++++++++++++++++++++++++++++++++++++++++

Modern C++ Overview Part One -

    1. Universal Initialization
        1. Initializer(s) within a pair of braces.
        2. Can be used with any type.
            int x{7};                           // Equivalent to int x = 7;
            std::string str{"Let us begin"};    // Equivalent to string str("Let us begin");
        3. Narrowing conversions are not allowed.
            int x = 7.7;   // Legal, although compilers may warn
            int x{7.7};    // Illegal
        4. It can be used with compound types.
            std::vector<int>vec{4,2,3,5,1};

    2. NULL
        1. Has the value 0.
        2. Its type is implementation defined.
            // Two functions which are overloaded
            void func(int);
            void func(int*);

            func(NULL); 
                // Calls func(int*) with clang
                // Calls func(int) with VC++
                // Does not compile with gcc

    3. nullptr (C++ 11 and above)
        1. A literal which represents a null pointer.
        2. It has a special type.
            1. Compatible with any pointer type.
            2. Cannot be converted to an integer.
            // Two functions which are overloaded
            void func(int);
            void func(int*);

            func(nullptr);    // Calls func(int*) as expected
    
    4. std::chrono durations
        1. Types which represent time intervals.
            1. Defined in <chrono>
            2. In the std::chrono namespace
            // Namespace alias to simplify the code
            namespace sc = std::chrono;
            sc::seconds(2);          // 2 second interval
            sc::milliseconds(20);    // 20 millisecond interval
            sc::microseconds(50);    // 50 microsecond interval

    5. std::chrono literals
        1. C++ 14 provides literals for these time intervals in the std::chrono::literals namespace.
        2. This is an inline namespace.
            using namespace std::literals;
            2s      // 2 second interval
            20ms    // 20 millisecond interval
            50us    // 50 microsecond interval
    
    6. auto type specifier, qualifier, and for-loop
        1. The compiler deduces the type from the initializer.
            auto x = 6;   // Equivalent to int x = 6;
            auto x{6};    // Equivalent to int x{6};    
        2. This is very useful with complicated types.
            std::vector<std::string>vec;
            auto it = vec.begin();    // Equivalent to std::vector<std::string>::iterator it = vec.begin();
        3. In modern C++, there are some cases where the type cannot be known by the programmer.
        4. auto will only give the underlying type.
            auto x = 6;    // x deduced as non-const
        5. const, reference, etc are ignored.
            const std::string& str = "Hello";    // Reference to a const string
            auto s = str;
                // s has type std::string
                // It is a mutable copy of str
        6. If we need them, we must add them ourselves
            const std::string& str = "Hello";
            const auto& s = str; 
                // s is a const reference to std::string
        7. We can use auto to simplify for-loop.
            std::vector<int>vec{4,3,1,2,5};
            for(auto it=vec.begin(); it!=vec.end(); ++it)
                std::cout<<*it<<" ";    // Prints out each element of vec
            for(auto it=vec.begin(); it!=vec.end(); ++it)
                *it+=2;    // Adds 2 to each element of vec 
        8. Special sysntax for iterating over containers. To visit each element once, in order, without adding or removing elements. Otherwise, use a traditional loop.    
            std::vector<int>vec{4,3,1,2,5};
            for(auto i: vec)
                std::cout<<i<<" ";    // Prints out each element of vec
            // We need to use a reference to modify the elements
            for(auto& i: vec) 
                i+=2;

Keep Coding!!!